;; Query Evaluator

(load "../../chapter3/3.3/table-obj-2d.scm")

(load "expression.scm")
(load "stream-utils.scm")
(load "pattern-matcher.scm")
(load "unifier.scm")
(load "rule.scm")

(define (make-qevaluator db)
  (let ((dt (make-table))
        (rule-counter 0))
    
    ;; Take as inputs a query and a stream of frames,
    ;; and return a stream of extended frames.
    (define (qeval query frame-stream)
      (let ((qproc (get (type query) 'qeval)))
        (if qproc
            (qproc (contents query) frame-stream)
            (simple-query query frame-stream))))

    ;; Simple queries
    ;;
    ;; Return the stream formed by extending each frame by
    ;; all data-base matches of the query.
    (define (simple-query query-pattern frame-stream)
      (stream-flatmap
       (lambda (frame)
         (stream-append-delayed
          (find-assertions query-pattern frame)
          (delay (apply-rules query-pattern frame))))
       frame-stream))

    ;; 'find-assertions' takes as input a pattern and a frame,
    ;; and returns a stream of frames, each extending the given one
    ;; by a data-base match of the given pattern.
    ;;
    ;; Optimisation:
    ;; The reason for 'fetch-assertions' here is that we can often
    ;; apply simple tests that will eliminate many of the entries
    ;; in the data base from the pool of candidates for
    ;; a successful match. This results in a smaller amount of
    ;; calls to the matcher.
    (define (find-assertions pattern frame)
      (stream-flatmap (lambda (datum)
                        (check-in-assertion datum pattern frame))
                      (fetch-assertions pattern frame)))

    ;; Check the pattern against the data in the given frame.
    (define (check-in-assertion assertion query-pat query-frame)
      (let ((match-result
             (pattern-match query-pat assertion query-frame)))
        (if (eq? match-result 'failed)
            the-empty-stream
            (singleton-stream match-result))))

    ;; 'apply-rules' is the rule analog of 'find-assertions'.
    ;;
    ;; It takes as input a pattern and a frame, and it forms
    ;; a stream of extension frames by applying rules from
    ;; the data base.
    (define (apply-rules pattern frame)
      (stream-flatmap (lambda (rule)
                        (apply-a-rule rule pattern frame))
                      (fetch-rules pattern frame)))

    ;; 'apply-a-rule' augments its argument frame by unifying
    ;; the rule conclusion with the pattern in the given frame.
    ;; If this succeeds, it evaluates the rule body in this new frame.
    ;;
    ;; In addition, the program renames all the variables in the rule
    ;; with unique new names to prevent the variables for different
    ;; rule applications from becoming confused with each other (ex. 4.79).
    (define (apply-a-rule rule query-pattern query-frame)
      (let ((clean-rule (rename-variables-in rule)))
        (let ((unify-result
               (unify-match query-pattern
                            (conclusion clean-rule)
                            query-frame)))
          (if (eq? unify-result 'failed)
              the-empty-stream
              (qeval (rule-body clean-rule)
                     (singleton-stream unify-result))))))

    ;; Unique variable names are generated by associating
    ;; a unique identifier with each rule application and
    ;; combining this identifier with the original variable
    ;; names.
    (define (rename-variables-in rule)
      (let ((rule-application-id (new-rule-application-id)))
        (define (tree-walk exp)
          (cond ((var? exp)
                 (make-new-variable exp rule-application-id))
                ((pair? exp)
                 (cons (tree-walk (car exp))
                       (tree-walk (cdr exp))))
                (else exp)))
        (tree-walk rule)))

    ;; The unique identifier for a rule application
    ;; is incremented each time a rule is applied.
    (define (new-rule-application-id)
      (set! rule-counter (+ 1 rule-counter))
      rule-counter)

    (define (make-new-variable var rule-application-id)
      (cons '? (cons rule-application-id (cdr var))))
    
    ;; Extensions support
    (define (extend-qeval type proc)
      (put type 'qeval proc))

    ;; Dispatch table procedures
    (define get (dt 'lookup-proc))
    (define put (dt 'insert-proc!))

    ;; Data base procedures
    (define fetch-assertions (db 'fetch-assertions))
    (define fetch-rules (db 'fetch-rules))

    ;; Interface to the rest of the system
    (define (dispatch m)
      (cond ((eq? m 'qeval) qeval)
            ((eq? m 'extend-qeval) extend-qeval)
            (else
             (error "Unknown operation MAKE-QEVALUATOR" m))))

    dispatch))
