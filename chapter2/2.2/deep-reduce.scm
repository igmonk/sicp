;; A side piece of work dedicated to the analysis of the recursive procedures used to
;; reduce a list/tree, specifically their commonalities and unique characteristics.

(load "../../common.scm")

;; The following procedures are considered:
;;
;; 1. count-leaves

(define (count-leaves x)
  (cond ((null? x) 0)
        ((not (pair? x)) 1)
        (else (+ (count-leaves (car x))
                 (count-leaves (cdr x))))))

;; 2. deep-reverse

(define (deep-reverse x)
  (cond ((null? x) x)
        ((not (pair? x)) x)
        (else (append (deep-reverse (cdr x))
                      (list (deep-reverse (car x)))))))

;; 3. fringe

(define (fringe x)
  (cond ((null? x) x)
        ((not (pair? x)) (list x))
        (else (append (fringe (car x))
                      (fringe (cdr x))))))


;; It is worth noticing, all of the procedures above share a common underlying pattern.
;;
;; They are made up of three parts:
;;   1) a base case when the list/tree is the empty list/tree
;;   2) a base case when the list/tree is a leaf
;;   3) a reduction step
;;
;; The most remarkable observation lies at the level of reduction.
;; The procedures reduce a given list/tree into different data structures:
;;   - count-leaves -> a number
;;   - deep-reverse -> a list/tree
;;   - fringe       -> a flat list/tree
;;
;; Each of the procedures can be generated by filling in slots in the same template:
;;
;; (define (<name> x)
;;   (cond ((null? x) <null-value>)
;;         ((not (pair? x)) (<leaf-fn> x))
;;         (else (<reduce-fn> (<name> (car x))
;;                            (<name> (cdr x))))))
;;
;; Hence, a general method of computation can be devised by taking the common template
;; and transforming the 'slots' into formal parameters:

(define (deep-reduce x null-value leaf-fn reduce-fn)
  (define (inner x)
    (cond ((null? x) null-value)
          ((not (pair? x)) (leaf-fn x))
          (else (reduce-fn (inner (car x))
                           (inner (cdr x))))))
  (inner x))


;; Each of the original procedures can be reformulated in terms of
;; the general method 'deep-reduce' as follows:


;; 1. count-leaves

(define (count-leaves x)
  (define (leaf-fn x) 1)
  (define (reduce-fn car-reduced cdr-reduced)
    (+ car-reduced cdr-reduced))
  (deep-reduce x 0 leaf-fn reduce-fn))


;; 2. deep-reverse

(define (deep-reverse x)
  (define (reduce-fn car-reduced cdr-reduced)
    (append cdr-reduced (list car-reduced)))
  (deep-reduce x '() identity reduce-fn))


;; 3. fringe

(define (fringe x)
  (define (leaf-fn x) (list x))
  (define (reduce-fn car-reduced cdr-reduced)
    (append car-reduced cdr-reduced))
  (deep-reduce x '() leaf-fn reduce-fn))


;; Moreover, there are some other useful procedures that could be easily implemented
;; given the general method 'deep-reduce'.


;; 4. traverse

(define (traverse x)
  (define (reduce-fn car-reduced cdr-reduced)
    (cons car-reduced cdr-reduced)) ;; <=> (append (list car-reduced) cdr-reduced))
  (deep-reduce x '() identity reduce-fn))


;; 5. leaves transforming traverse and its concrete applications
;;
;; None of the lt-traverse instances modifies the structure of its input:
;; a list/tree preserves its initial structure, while its leaves are subject to change.

(define (lt-traverse x leaf-fn)
  (define (reduce-fn car-reduced cdr-reduced)
    (cons car-reduced cdr-reduced))
  (deep-reduce x '() leaf-fn reduce-fn))

(define (identity-traverse x)
  (lt-traverse x identity))

(define (square-traverse x)
  (lt-traverse x square))

(define (cube-traverse x)
  (lt-traverse x cube))

(define x (list (list 1 2) (list 3 4)))

;; x                     ; ((1 2) (3 4))
;; (count-leaves x)      ; 4
;; (deep-reverse x)      ; ((4 3) (2 1))
;; (fringe x)            ; (1 2 3 4)
;; (traverse x)          ; ((1 2) (3 4))
;; (identity-traverse x) ; ((1 2) (3 4))
;; (square-traverse x)   ; ((1 4) (9 16))
;; (cube-traverse x)     ; ((1 8) (27 64))

(define xx (list (list 1 2) (list 3 4) (list 5 6)))

;; xx                     ; ((1 2) (3 4) (5 6))
;; (count-leaves xx)      ; 6
;; (deep-reverse xx)      ; ((6 5) (4 3) (2 1))
;; (fringe xx)            ; (1 2 3 4 5 6)
;; (traverse xx)          ; ((1 2) (3 4) (5 6))
;; (identity-traverse xx) ; ((1 2) (3 4) (5 6))
;; (square-traverse xx)   ; ((1 4) (9 16) (25 36))
;; (cube-traverse xx)     ; ((1 8) (27 64) (125 216))

(define xxx (list (list (list 1 2) (list 3 4))
                  (list (list 5 6) (list 7 8))))

;; xxx                     ; (((1 2) (3 4)) ((5 6) (7 8)))
;; (count-leaves xxx)      ; 8
;; (deep-reverse xxx)      ; (((8 7) (6 5)) ((4 3) (2 1)))
;; (fringe xxx)            ; (1 2 3 4 5 6 7 8)
;; (traverse xxx)          ; (((1 2) (3 4)) ((5 6) (7 8)))
;; (identity-traverse xxx) ; (((1 2) (3 4)) ((5 6) (7 8)))
;; (square-traverse xxx)   ; (((1 4) (9 16)) ((25 36) (49 64)))
;; (cube-traverse xxx)     ; (((1 8) (27 64)) ((125 216) (343 512)))
