;; Exercise 5.31
;;
;; In evaluating a procedure application,
;; the explicit-control evaluator always
;; - saves and restores the env register around the evaluation of
;;   the operator,
;; - saves and restores env around the evaluation of each operand
;;   (except the final one),
;; - saves and restores argl around the evaluation of each operand
;; - and saves and restores proc around the evaluation of
;;   the operand sequence.
;;
;; For each of the following combinations, say which of these
;; save and restore operations are superfluous and thus could be
;; eliminated by the compiler's preserving mechanism:
;;
;; (f 'x 'y)
;; ((f) 'x 'y)
;; (f (g 'x) y)
;; (f (g 'x) 'y)


;; In order to identify those unnecessary stack operations performed
;; by the explicit-control evaluator and eliminated by the compiler,
;; it is useful to compare the code generated by the compiler with
;; and without the optimization mechanism implemented in the sequence
;; combiner 'preserving' (as in exercise 5.37).
;;
;; The effect can be achieved by having the procedure preserving
;; changed to:

(define (preserving regs seq1 seq2)
  (if (null? regs)
      (append-instruction-sequences seq1 seq2)
      (let ((first-reg (car regs)))
        (preserving
         (cdr regs)
         (make-instruction-sequence
          (list-union (list first-reg)
                      (registers-needed seq1))
          (list-difference (registers-modified seq1)
                           (list first-reg))
          (append `((save ,first-reg))
                  (statements seq1)
                  `((restore ,first-reg))))
         seq2))))


(load "compiler-factory.scm")
(load "io-utils.scm")

(define compiler1 (create-compiler))
(define compile (compiler1 'compile))


;; 1. (f 'x 'y)

(define compiled-1
  (compile
   '(f 'x 'y)
   'val
   'next))

(instruction-seq->file compiled-1 "5.31.1.obj")


;; Compiled code (unoptimized)
;;
;; All the stack operations are superfluous, since none of
;; the operations involved (looking up variable value, quote,
;; procedure application) require preserving a register that
;; is modified by the preceding operation.
(save continue)
(save env)
(save continue)
(assign proc (op lookup-variable-value) (const f) (reg env))
(restore continue)
(restore env)
(restore continue)
(save continue)
(save proc)
(save env)
(save continue)
(assign val (const y))
(restore continue)
(assign argl (op list) (reg val))
(restore env)
(save argl)
(save continue)
(assign val (const x))
(restore continue)
(restore argl)
(assign argl (op cons) (reg val) (reg argl))
(restore proc)
(restore continue)
(test (op primitive-procedure?) (reg proc))
(branch (label primitive-branch3))
compiled-branch2
(assign continue (label after-call1))
(assign val (op compiled-procedure-entry) (reg proc))
(goto (reg val))
primitive-branch3
(save continue)
(assign val (op apply-primitive-procedure) (reg proc) (reg argl))
(restore continue)
after-call1


;; Compiled code (optimized)

(assign proc (op lookup-variable-value) (const f) (reg env))
(assign val (const y))
(assign argl (op list) (reg val))
(assign val (const x))
(assign argl (op cons) (reg val) (reg argl))
(test (op primitive-procedure?) (reg proc))
(branch (label primitive-branch3))
compiled-branch2
(assign continue (label after-call1))
(assign val (op compiled-procedure-entry) (reg proc))
(goto (reg val))
primitive-branch3
(assign val (op apply-primitive-procedure) (reg proc) (reg argl))
after-call1



;; 2. ((f) 'x 'y)

(define compiled-2
  (compile
   '((f) 'x 'y)
   'val
   'next))

(instruction-seq->file compiled-2 "5.31.2.obj")


;; Compiled code (unoptimized)
;;
;; Same as in the previous example - all the stack operations
;; are superfluous. The evaluation of 'x and 'y (quoted) does not
;; require saving and restoring even the register env, which
;; might get modified by the preceding procedure call.
(save continue)
(save env)
(save continue)
(save env)
(save continue)
(assign proc (op lookup-variable-value) (const f) (reg env))
(restore continue)
(restore env)
(restore continue)
(save continue)
(save proc)
(assign argl (const ()))
(restore proc)
(restore continue)
(test (op primitive-procedure?) (reg proc))
(branch (label primitive-branch3))
compiled-branch2
(assign continue (label proc-return4))
(assign val (op compiled-procedure-entry) (reg proc))
(goto (reg val))
proc-return4
(assign proc (reg val))
(goto (label after-call1))
primitive-branch3
(save continue)
(assign proc (op apply-primitive-procedure) (reg proc) (reg argl))
(restore continue)
after-call1
(restore env)
(restore continue)
(save continue)
(save proc)
(save env)
(save continue)
(assign val (const y))
(restore continue)
(assign argl (op list) (reg val))
(restore env)
(save argl)
(save continue)
(assign val (const x))
(restore continue)
(restore argl)
(assign argl (op cons) (reg val) (reg argl))
(restore proc)
(restore continue)
(test (op primitive-procedure?) (reg proc))
(branch (label primitive-branch7))
compiled-branch6
(assign continue (label after-call5))
(assign val (op compiled-procedure-entry) (reg proc))
(goto (reg val))
primitive-branch7
(save continue)
(assign val (op apply-primitive-procedure) (reg proc) (reg argl))
(restore continue)
after-call5


;; Compiled code (optimized)

(assign proc (op lookup-variable-value) (const f) (reg env))
(assign argl (const ()))
(test (op primitive-procedure?) (reg proc))
(branch (label primitive-branch3))
compiled-branch2
(assign continue (label proc-return4))
(assign val (op compiled-procedure-entry) (reg proc))
(goto (reg val))
proc-return4
(assign proc (reg val))
(goto (label after-call1))
primitive-branch3
(assign proc (op apply-primitive-procedure) (reg proc) (reg argl))
after-call1
(assign val (const y))
(assign argl (op list) (reg val))
(assign val (const x))
(assign argl (op cons) (reg val) (reg argl))
(test (op primitive-procedure?) (reg proc))
(branch (label primitive-branch7))
compiled-branch6
(assign continue (label after-call5))
(assign val (op compiled-procedure-entry) (reg proc))
(goto (reg val))
primitive-branch7
(assign val (op apply-primitive-procedure) (reg proc) (reg argl))
after-call5



;; 3. (f (g 'x) y)

(define compiled-3
  (compile
   '(f (g 'x) y)
   'val
   'next))

(instruction-seq->file compiled-3 "5.31.3.obj")


;; Compiled code (unoptimized)
;;
;; The registers proc and argl must be preserved over the evaluation
;; of the first operand to f, since it's a procedure application
;; that modifies both proc and argl (which are needed later to apply f).
;;
;; The register env does need to be preserved due to the order of
;; evaluation of the procedure arguments - the last is evaluated first.
;; Hence, after y has been evaluated in the current environment
;; (which does not modify env), there is no more need to preserve env.
(save continue)
(save env)
(save continue)
(assign proc (op lookup-variable-value) (const f) (reg env))
(restore continue)
(restore env)
(restore continue)
(save continue)
(save proc)
(save env)
(save continue)
(assign val (op lookup-variable-value) (const y) (reg env))
(restore continue)
(assign argl (op list) (reg val))
(restore env)
(save argl)
(save continue)
(save env)
(save continue)
(assign proc (op lookup-variable-value) (const g) (reg env))
(restore continue)
(restore env)
(restore continue)
(save continue)
(save proc)
(save continue)
(assign val (const x))
(restore continue)
(assign argl (op list) (reg val))
(restore proc)
(restore continue)
(test (op primitive-procedure?) (reg proc))
(branch (label primitive-branch3))
compiled-branch2
(assign continue (label after-call1))
(assign val (op compiled-procedure-entry) (reg proc))
(goto (reg val))
primitive-branch3
(save continue)
(assign val (op apply-primitive-procedure) (reg proc) (reg argl))
(restore continue)
after-call1
(restore argl)
(assign argl (op cons) (reg val) (reg argl))
(restore proc)
(restore continue)
(test (op primitive-procedure?) (reg proc))
(branch (label primitive-branch6))
compiled-branch5
(assign continue (label after-call4))
(assign val (op compiled-procedure-entry) (reg proc))
(goto (reg val))
primitive-branch6
(save continue)
(assign val (op apply-primitive-procedure) (reg proc) (reg argl))
(restore continue)
after-call4


;; Compiled code (optimized)

(assign proc (op lookup-variable-value) (const f) (reg env))
(save proc)
(assign val (op lookup-variable-value) (const y) (reg env))
(assign argl (op list) (reg val))
(save argl)
(assign proc (op lookup-variable-value) (const g) (reg env))
(assign val (const x))
(assign argl (op list) (reg val))
(test (op primitive-procedure?) (reg proc))
(branch (label primitive-branch3))
compiled-branch2
(assign continue (label after-call1))
(assign val (op compiled-procedure-entry) (reg proc))
(goto (reg val))
primitive-branch3
(assign val (op apply-primitive-procedure) (reg proc) (reg argl))
after-call1
(restore argl)
(assign argl (op cons) (reg val) (reg argl))
(restore proc)
(test (op primitive-procedure?) (reg proc))
(branch (label primitive-branch6))
compiled-branch5
(assign continue (label after-call4))
(assign val (op compiled-procedure-entry) (reg proc))
(goto (reg val))
primitive-branch6
(assign val (op apply-primitive-procedure) (reg proc) (reg argl))
after-call4



;; 4. (f (g 'x) 'y)

(define compiled-4
  (compile
   '(f (g 'x) 'y)
   'val
   'next))

(instruction-seq->file compiled-4 "5.31.4.obj")


;; Compiled code (unoptimized)
;;
;; The only preserving of proc and argl is necessary, since (g 'x)
;; modifies both proc and argl that are needed for the application
;; of f.
(save continue)
(save env)
(save continue)
(assign proc (op lookup-variable-value) (const f) (reg env))
(restore continue)
(restore env)
(restore continue)
(save continue)
(save proc)
(save env)
(save continue)
(assign val (const y))
(restore continue)
(assign argl (op list) (reg val))
(restore env)
(save argl)
(save continue)
(save env)
(save continue)
(assign proc (op lookup-variable-value) (const g) (reg env))
(restore continue)
(restore env)
(restore continue)
(save continue)
(save proc)
(save continue)
(assign val (const x))
(restore continue)
(assign argl (op list) (reg val))
(restore proc)
(restore continue)
(test (op primitive-procedure?) (reg proc))
(branch (label primitive-branch3))
compiled-branch2
(assign continue (label after-call1))
(assign val (op compiled-procedure-entry) (reg proc))
(goto (reg val))
primitive-branch3
(save continue)
(assign val (op apply-primitive-procedure) (reg proc) (reg argl))
(restore continue)
after-call1
(restore argl)
(assign argl (op cons) (reg val) (reg argl))
(restore proc)
(restore continue)
(test (op primitive-procedure?) (reg proc))
(branch (label primitive-branch6))
compiled-branch5
(assign continue (label after-call4))
(assign val (op compiled-procedure-entry) (reg proc))
(goto (reg val))
primitive-branch6
(save continue)
(assign val (op apply-primitive-procedure) (reg proc) (reg argl))
(restore continue)
after-call4


;; Compiled code (optimized)

(assign proc (op lookup-variable-value) (const f) (reg env))
(save proc)
(assign val (const y))
(assign argl (op list) (reg val))
(save argl)
(assign proc (op lookup-variable-value) (const g) (reg env))
(assign val (const x))
(assign argl (op list) (reg val))
(test (op primitive-procedure?) (reg proc))
(branch (label primitive-branch3))
compiled-branch2
(assign continue (label after-call1))
(assign val (op compiled-procedure-entry) (reg proc))
(goto (reg val))
primitive-branch3
(assign val (op apply-primitive-procedure) (reg proc) (reg argl))
after-call1
(restore argl)
(assign argl (op cons) (reg val) (reg argl))
(restore proc)
(test (op primitive-procedure?) (reg proc))
(branch (label primitive-branch6))
compiled-branch5
(assign continue (label after-call4))
(assign val (op compiled-procedure-entry) (reg proc))
(goto (reg val))
primitive-branch6
(assign val (op apply-primitive-procedure) (reg proc) (reg argl))
after-call4
